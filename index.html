<!DOCTYPE html><html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="version" content="1.0.0">
<meta name="application-name" content="SkeleWiki">
<title>SkeleWiki</title>
<style id="css">
:root {
	--text: #000;
	--font: serif;
	--size: 13pt;
	--space: .5rem;
	--pad: var(--space) calc(var(--space) * 2);
	--bg: #ffd;
	--accent1: #682;
	--accent2: #639;
	--dull: #eda;
	--bad: #f64;
	--link-style: underline;
	--btn-pad: calc(var(--space) / 2) var(--space);
	--btn-border: none;
	--rounded: 3px;
	--max-width: 1200px;
}
* {
	box-sizing: border-box;
	font-family: var(--font);
	color: var(--text);
	font-size: var(--size);
	line-height: 1.15em;
	background: transparent;
}
* * {
	font-family: inherit;
	color: inherit;
	font-size: inherit;
	line-height: inherit;
}
*[hidden],
dialog:not([open]),
main>section,
#results:empty {
	display: none;
}
code,
kbd {
	font-family: monospace;
	font-size: .8em;
}
code {
	background: var(--dull);
	padding: calc(var(--space) / 3) calc(var(--space) / 2);
}
pre>code {display: block}
dialog[open] {
	display: block;
	background: var(--bg);
}
html {background: var(--bg)}
body>header,
#settings,
main {
	padding: var(--pad);
	width: 100%;
	max-width: var(--max-width);
}
nav ul li a:empty::after,
main:empty::after,
main>section article:empty::after {
	content: "No content";
}
*+* {margin: var(--space) 0 0}
main>section+section {margin: 0}
#wiki a {color: var(--accent1)}
#wiki #desc {margin-left: var(--space)}
#actions {
	display: flex;
	gap: var(--space);
	align-items: center;
}
#actions>* {margin: 0}
h1,
h2,
h3,
h4,
h5,
h6 {
	margin: calc(var(--space) * 3) 0;
}
main,
main>section>h1,
form h1 {
	margin-top: 0;
}
h1 {font-size: 2.2rem}
h2 {font-size: 1.8rem}
h3,
#wiki #name {
	font-size: 1.5rem;
}
h4 {font-size: 1.15rem}
h1,
h2,
h3,
h4,
h5,
#wiki #name {
	font-weight: bold;
}
h5,
h6 {
	font-style: italic;
}
h6 {font-weight: normal}
a {
	color: var(--accent2);
	text-decoration: var(--link-style);
}
button {
	background: var(--accent1);
	color: #fff;
	border: var(--btn-border);
	border-radius: var(--rounded);
	padding: var(--btn-pad);
	cursor: pointer;
	font-weight: 500;
}
button.other {background: var(--accent2)}
button.dull {
	background: var(--dull);
	font-weight: normal;
	color: var(--text);
}
button.bad {background: var(--bad)}
label {
	display: block;
	font-weight: 500;
}
input,
textarea,
select,
option {
	padding: var(--btn-pad);
	background: var(--bg);
	border: 1px solid var(--text);
	border-radius: var(--rounded);
}
textarea {
	min-height: 300px;
	width: 100%;
	max-width: 600px;
}
nav ul {
	margin: var(--space) 0;
	padding: var(--space) 0;
	border-top: 1px solid var(--text);
	list-style: none;
}
nav ul li {
	display: inline-block;
	margin: var(--space);
}
.sm {font-size: .8em}
#search {position: relative}
#results {
	position: absolute;
	background: var(--bg);
	border: 1px solid #000;
	top: calc(var(--size) + .25rem);
	left: 0;
	width: 100%;
	max-height: 300px;
	overflow-y: auto;
	overflow-x: hidden;
	padding: 0;
	border-radius: var(--rounded);
	z-index: 9;
}
#results a {
	display: block;
	width: 100%;
	padding: var(--btn-pad);
	margin: 0;
	color: #000;
}
#results a:hover {
	color: #fff;
	background: var(--accent2);
}
mark {
	background: var(--accent1);
	color: white;
}
main>section>footer>time {cursor: help}
main>section>footer>time::before {content: 'Updated '}
</style>
</head>
<body>
<header>
	<section id="wiki">
		<a href="javascript:go()" id="name">SkeleWiki</a>
		<span id="desc">A <em>dead</em> simple tool to make bare <em>bones</em> multi-page websites in a single HTML file.</span>
	</section>
	<section id="actions">
		<div id="search" style="flex:1">
			<input type="search" placeholder="Search">
			<div id="results"></div>
		</div>
		<div style="flex:2;text-align:right">
			<button id="settingsBtn" class="dull" onclick="settings()">Settings</button>
			<button id="newBtn" class="other" onclick="add()">New Page</button>
			<button id="saveBtn" onclick="save()">Save</button>
		</div>
	</section>
	<nav><ul></ul></nav>
</header>
<dialog id="settings">
	<h1>Settings</h1>
	<form method="dialog" onsubmit="update(event.target)">
		<label>Wiki Name<br><input name="name"></label>
		<label>Wiki Description<br><input name="desc"></label>
		<label>Wiki CSS<br><textarea name="css"></textarea></label>
		<footer>
			<button type="submit">Save</button>
			<button type="button" class="dull" onclick="settings(true)">Cancel</button>
		</footer>
	</form>
</dialog>
<main><section id="1707517025349" style="display: block;"><h1>About SkeleWiki</h1>
<pre>SkeleWiki is a super hackable, self-replicating web app that lets you create inter-linking pages formatted with Markdown. All data created with SkeleWiki is simply stored directly as HTML on the page, and the code within the HTML file is not minified at all, making it easier to simply crack open in a text editor and modify however you wish!

It's page management with Markdown formatting and a simple search bar all rolled up into a single HTML file that's _less than 20 kilobytes!_

## How to Use

Just &lt;a href="https://codeberg.org/Alamantus/SkeleWiki/raw/branch/main/skelewiki.html" download="skelewiki.html" target="_blank"&gt;download the SkeleWiki HTML file&lt;/a&gt; and open it in a browser to get started. It's pretty simple:

- Use the "Settings" button to change the wiki's name, description, and CSS, then push "Save" to make your changes.
- Create a new page by using the "New Page" button. This will create an empty page that you can start editing right away.
	- Set a page title in the "Name" field and write some text for the page with Markdown formatting.
		- In addition to Markdown, you can link between pages using wiki link format by putting the (case insensitive) page name in 2 square braces \[\[like this\]\]! If you want the link to have different text than the page's name, then put the page name first then the text to display after a vertical bar \[\[other page|like this\]\]!
	- If you have multiple pages, you can change the order they display in the navigation by changing the Sort Position.
	- The page in the `0` position will be the "home" page of your SkeleWiki that is displayed when the file loads or when the Wiki Title is clicked.
	- Use "Save" to save the page and view the page.
	- Use "Cancel" to prevent any changes from being saved (results in an empty page if it's newly created).
	- Use "Delete" to remove the page and navigation entry.
- Search for text in your pages using the Search bar. Check the Particularities below for exactly how the results are found &amp; sorted.
- Click the "Edit" button at the bottom of a page to change that page. The date at the bottom of the page will be updated when you save your changes.
- Save your changes to a new HTML file by using the "Save" button (or &lt;kbd&gt;Ctrl&lt;/kbd&gt;/&lt;kbd&gt;Command&lt;/kbd&gt; + &lt;kbd&gt;S&lt;/kbd&gt;). The HTML file defaults to a lowercase version of your wiki's name with any non-alphanumeric characters converted to underscores `like_this.html`.

And that's pretty much it!

If you want to get a good idea of how to use SkeleWiki, you can make changes to and download _this_ site by just clicking the "Save" button in the top right corner! Any changes you make will be saved as a new file on your computer, but they aren't permanent and will reset if you refresh the page.

### Particularities

Being a tiny platform with as little unnecessary functionality as possible, there are some behaviors that you should keep in mind while using it. Here's everything that might be unexpected in no particular order:

- New pages are always added to the end of the page order, and thus the end of the nav bar.
- Pages without a name cannot be linked to and display in the navigation as "No content."
- Navigating to a different page while editing will change the page _immediately_ and **discard any unsaved changes** to the page.
- Page names must be unique or else wiki links won't work unless you find and use the page's id instead of its name!
	- You can find the page's id by hovering over its nav menu item.
- If you use a wiki link to a page that doesn't exist, nothing will happen when you click it.
- When editing a page, pressing &lt;kbd&gt;Tab&lt;/kbd&gt; in the Markdown Content text area (also the Wiki CSS text area in Settings) will type a `Tab` character instead of changing focus to the next form element.
	- Holding &lt;kbd&gt;Shift&lt;/kbd&gt; while pressing &lt;kbd&gt;Tab&lt;/kbd&gt; _will_ navigate to the previous element as expected.
- You _can_ use HTML in the wiki name and description, but should you?
- The Wiki CSS is actually the literal contents of the `&lt;style&gt;` tag in the HTML's head. You can change it however you wish, but it might affect the wiki's page structure if you remove too much stuff.
- Every page exists in the file's HTML, but all pages except for the current one are hidden by default.
- The "Updated" timestamp at the bottom of a page is set to _your_ local date and time.
- Hover over the "Updated" timestamp at the bottom of a page to see the timestamp of when the page was first created, i.e. the moment "New Page" was pressed.
- Search prioritizes exact matches over case-insensitive ones and will display matching pages in order by where the match is found, prioritizing page names over page text, and only the text content of the parsed Markdown is searched when looking for results within the page text.
- Very large amounts of content on a page and very large numbers of pages may affect the performance of your SkeleWiki because it just uses and manipulates the raw DOM.
- Only the Markdown of each page is saved and can be found directly in the HTML file within a `pre` tag in the page's `section` tag. It's parsed into formatted HTML that displays when the page is loaded and the JavaScript runs.
- All pages are on the same level and display in the wiki nav bar.</pre>
<article hidden="true"></article>
<footer>
<time title="Created 2/9/2024, 3:17:05 PM">2/14/2024, 22:29:10 PM</time> <button class="dull editButton" onclick="edit(1707517025349)">Edit</button>
</footer></section><section id="1707517176500" style=""><h1>Markdown Support</h1>
<pre>Click the "Edit" button at the bottom of the page to see the markdown source!

---

&lt;!--This means we can use HTML elements in Markdown, such as the comment
element, and they won't be affected by a markdown parser. However, if you
create an HTML element in your markdown file, you cannot use markdown syntax
within that element's contents.--&gt;

# This is an `&lt;h1&gt;`
## This is an `&lt;h2&gt;`
### This is an `&lt;h3&gt;`
#### This is an `&lt;h4&gt;`
##### This is an `&lt;h5&gt;`
###### This is an `&lt;h6&gt;`

This is an h1
=============

This is an h2
-------------

*This text is in italics.*
_And so is this text._

**This text is in bold.**
__And so is this text.__

***This text is in both.***
**_As is this!_**
*__And this!__*

~~This text is rendered with strikethrough.~~

This is a paragraph. I'm typing in a paragraph isn't this fun?

Now I'm in paragraph 2.
I'm still in paragraph 2 too!


I'm in paragraph three!

I end with two spaces (highlight me to see them).

There's a `&lt;br /&gt;`  
above me!

&gt; This is a block quote. You can either
&gt; manually wrap your lines and put a `&gt;` before every line or you can let your lines get really long and wrap on their own.
&gt; It doesn't make a difference so long as they start with a `&gt;`.

&gt; You can only use one level
&gt;&gt; of indentation?
&gt;&gt; Oh well!

* Item
* Item
* Another item

or

+ Item
+ Item
+ One more item

or

- Item
- Item
- One last item

- List
	- Indentation
		- also
	- works!
- (with
	- two
	- spaces)

1. Item one
2. Item two
3. Item three

1. Item one
1. Item two
1. Item three

1. Item one
2. Item two
3. Item three
	* mixing
	* Sub-list types
4. Item four

Boxes below without the 'x' are unchecked HTML checkboxes.
- [ ] First task to complete.
- [ ] Second task that needs done

This checkbox below will be a checked HTML checkbox.

- [x] This task has been completed

```
This is code
				So is this
```

```javascript
function canLabelCode() {
		return true;
}
```

\`\`\`
Here's some \&lt;Escaped text!\&gt;
\`\`\`

John didn't even know what the `go_to()` function did!

***

---

- - -

****************

[Click me!](http://test.com/)

[Click me!](http://test.com/ "Link to Test.com")

[Go to music](/music/).

- [Heading](#heading)
- [Another heading](#another-heading)
- [Chapter](#chapter)
	- [Subchapter &lt;h3 /&gt;](#subchapter-h3-)

![This is the alt-attribute for my image](http://imgur.com/myimage.jpg "An optional title")

&lt;http://testwebsite.com/&gt; is equivalent to
[http://testwebsite.com/](http://testwebsite.com/)

&lt;foo@bar.com&gt;

I want to type *this text surrounded by asterisks* but I don't want it to be
in italics, so I do this: \*this text surrounded by asterisks\*.

Your computer crashed? Try sending a
&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</pre>
<article hidden="true"></article>
<footer>
<time title="Created 2/9/2024, 3:19:36 PM">2/9/2024, 3:20:16 PM</time> <button class="dull editButton" onclick="edit(1707517176500)">Edit</button>
</footer></section><section id="1707517259013" style=""><h1>Hacking SkeleWiki</h1>
<pre>Since it's literally just an HTML file with all its code visibly formatted in the way the developer writes it, you can just change the content or behavior! All you need is a text editor and a basic understanding of web development (HTML, CSS, and JavaScript).

The only HTML altered by the app is:

- The `&lt;a id="name"&gt;` element in the wiki header
- The `&lt;span id="desc"&gt;` element in the wiki header
- The `&lt;div id="results"&gt;` element in the wiki header
- The CSS within the `&lt;style id="css"&gt;` element in the HTML `head`
- The HTML content within the `&lt;main&gt;` element.

Pretty much anywhere else is untouched by the JavaScript and can be modified. If you need to add meta tags to the head or additional code, you can just do that. In addition, all the app functions can be accessed through `window` in JavaScript. There are also a couple helper methods in there to keep the code small.

All the functions that control the app are set directly in the `window` and include some basic comments to help you know what everything does, and all the site data is stored directly in the HTML within `&lt;pre&gt;` tags as Markdown. The only thing to be aware of is that all HTML elements (i.e. `&lt;` and `&gt;` characters) are stored as HTML entities (i.e. `&amp;lt;` and `&amp;gt;`). If processing the Markdown outside of SkeleWiki, be sure to re-encode the HTML entities into their appropriate characters or else it may not parse properly.

## App Reference

Below are all of the functions and global variables used to make SkeleWiki function with additional details to help clarify their use:

- `add()`: Create a new page element &amp; start editing.
- `ce(tagName: string)`: Short alias of `document.getElementById`.
- `current: string`: The current page id.
- `del(pageId: string|number)`: Delete the page with the given id. Asks for confirmation before deletion.
- `edit(pageId: string|number, yes: boolean = true)`: Show (default) or hide a form to edit the page with given id. Also updates nav entry.
- `gebi(id: string)`: Short alias of `document.getElementById()`.
- `go(pageIdOrName?: string, back: boolean = false)`: Show page element with given name or id, or home page if none is given. If back == true, don't update url hash
- `h(hash?: string)`: Get and/or set the URL hash. If `hash` is set, then set the URL hash. Either way, it returns the current URL hash from `window.location.hash`.
- `handleTab()`: Sets the `onkeydown` attribute of all existing `&lt;textarea&lt;` elements without class `notab` to enable typing the `Tab` character when <kbd>Tab</kbd> is typed. If <kbd>Shift</kbd> is held, the focus will move to the previous focusable element instead of inserting a `Tab`.
- `info(element: HTMLElement)`: Get page details as object from the given element. Object contains the page element's `id` as a string, page `name` as a string, and `src` containing the raw Markdown content of the page.
- `main: HTMLElement`: Reference to the `&lt;main&gt;` HTMLElement
- `md(markdown?: string)`: Parse given Markdown into HTML. If empty, returns an empty string.
- `nav: HTMLUListElement`: Reference to the `&lt;ul&gt;` element within the `&lt;nav&gt;` in the site header.
- `navItem(element: HTMLElement)`: Given a page element, return a new `&lt;li&gt;` element to insert into the site nav with a link to the given page with text equal to the name of the page.
- `pages()`: Get all current page HTMLElements as an array.
- `q(selector: string, element?: HTMLElement)`: Short alias of `querySelector()`. If no `element` is provided, `document` is used by default.
- `qa(selector: string, element?: HTMLElement)`: Short alias of `document.querySelectorAll()`. If no `element` is provided, `document` is used by default.
- `render(pageId?: string)`: If `pageId` is given, re-render stored Markdown directly into the element &amp; update nav text. Otherwise, re-render all stored Markdown into the `&lt;main&gt;` element and re-create the `&lt;nav&gt;` element.
- `res: HTMLElement`: Reference to the element where search results are displayed. If empty, the element is hidden.
- `save()`: Reset to default state, remove rendered Markdown, start download of HTML file, and then reset the display to current view.
- `sBar: HTMLInputElement`: Reference to the `&lt;input&gt;` element where searches are done. The element has event listeners on the `keydown` and `focus` events to run `search()` using the input value when triggered.
- `search(term: string)`: Check all pages for text matching the given term. If no results or an empty `term` are provided, the `res` element will be empty and not visible, otherwise it will display the search results.
- `settingFields()`: Get the names of all form inputs within the settings dialog. These field names are intended to match an HTMLElement id elsewhere in the HTML.
- `settings(close?: boolean)`: Show (default) or hide settings dialog. When opened, the field values are populated with the `innerHTML` of the HTMLElements with the same name as the `&lt;input&gt;` elements.
- `show(element: HTMLElement, yes: boolean = true)`: Show (default) or hide the given page element. Page `&lt;section&gt;` elements are hidden by default and displayed by setting `style="display:block"` on the element. If `yes` is set to `false`, then the `display` style is removed, hiding the page.
- `update(form: HTMLFormElement)`: Save the settings dialog &amp; update innerHTML of all elements with ids matching the input name within the `&lt;form&gt;`.
- `wikiLinks(text: string)`: Parse all \[\[wiki links\]\] in the given text into HTML `&lt;a&gt;` tags that link to the name or id of the page within the double braces using `javascript:go()` as the `href` attribute. The link text can be set by using a vertical bar `|` to separate the page name/id and the link text \[\[other page|like this\]\].

## Ideas

- Don't want your updated time visible on a page? Find the `main&gt;section&gt;footer&gt;time` entry in the Wiki CSS and add `display: none;` to hide it.
	- Don't want it in the HTML at all? Then you'll need to update the code to stop the `&lt;time&gt;` elements from being created and then remove them from your HTML. It's set in the `add()` method and modified in the `edit()` method.
- Need SkeleWiki in your own language? Just modify the UI text in the HTML file!
- Want to restructure the whole app? You can change the CSS and HTML completely if you need to! Just check the code for any expected structure patterns first so you don't break anything.
- Don't like the Markdown parser? Replace it! As long as whatever parser you use has its parse function set to `window.md()`, SkeleWiki should handle it fine!</pre>
<article hidden="true"></article>
<footer>
<time title="Created 2/9/2024, 3:20:59 PM">2/14/2024, 22:57:41 PM</time> <button class="dull editButton" onclick="edit(1707517259013)">Edit</button>
</footer></section><section id="1707872418096" style=""><h1>Publishing</h1>
<pre>If you're done working on your SkeleWiki's content, all you really need to do to publish your work is upload the HTML file somewhere that can be accessed by a web browser. But if you want to present it in a way that looks a little more finalized, there are a few things you can do to make your finished product even better!

## Hide the Edit Buttons

The easiest way to make your SkeleWiki not immediately editable would be to simply hide the management buttons that create and edit pages. You can do that by simply adding some CSS to make them not display:

```css
#actions :last-child,
.editBtn {
	display: none;
}
```

Keep in mind that simply hiding the buttons means that they are still present in the HTML, so if that bothers you, you might want to look into the more drastic option of _deleting_ the HTML.

The primary benefit of simply hiding the buttons is that you can un-hide them later and use them to make changes to your site as normal, but they do remain as an extra little bit of dead weight in the HTML.

## _Remove_ the Edit Buttons

This option may be a bit more dramatic than necessary since the vast majority of people aren't going to be looking at your site's raw HTML, but if you want to take that extra step, you can run the following script to remove all the edit buttons from the code:

```javascript
qa('#actions :last-child, .editBtn').forEach(el =&gt; el.parentNode.removeChild(el));
```

You can run this in your browser's inspector console and then save your wiki with &lt;kbd&gt;Ctrl&lt;/kbd&gt; or &lt;kbd&gt;Command&lt;/kbd&gt; + &lt;kbd&gt;S&lt;/kbd&gt; to make it permanent. The new file will be missing the "Settings," "New Page," and "Save" buttons in addition to the "Edit" button on every page.

An additional benefit of removing these buttons is that it reduces the final size of your HTML file a little bit more. You can go one step further and remove no longer needed SkeleWiki code like the `add()`, `del()`, and `edit()` functions, but that will prevent you from making any new pages ever again. If you keep them in the code, you will still be able to use your browser's inspector to manage your site in case you need to make edits.

## Minify the File

SkeleWiki is already quite small, but it can absolutely be smaller. The official HTML is not minified for the purpose of remaining easily hackable by anyone who wants to dig into the code, so running the HTML through a minifier to remove extra spaces and comments will immediately make HTML much smaller!

For example, using one minifier online brought version 1.0.0 of the SkeleWiki core down from about 19 to only 13 kilobytes! Using it on your site's HTML in addition to just the SkeleWiki code will help keep your final HTML size as small as possible, making your site display practically instantaneously.

## Add Offline Mode

This is optional and actually adds extra code for your users to download, but the benefit is that after they visit your site once, they'll be able to access a copy of the data on the site for as long as their browser cache doesn't get cleared even if they don't have internet access or your server goes down.

You can very easily add a script called [UpUp](https://www.talater.com/upup/) and have your offline site available with hardly any work! Download &lt;a href="https://github.com/TalAter/UpUp/blob/master/dist/upup.zip"&gt;`upup.zip` from the GitHub Repo&lt;/a&gt;, extract the files, and put the `upup.min.js` &amp; `upup.sw.min.js` files in the same directory as your SkeleWiki file on your server. Then in the HTML, just add this script tag before the closing body tag:

```html
&lt;script src="upup.min.js"&gt;&lt;/script&gt;
&lt;script&gt;
UpUp.start({
  'content-url': 'index.html',
});
&lt;/script&gt;
```

Replace `index.html` with the actual name of your SkeleWiki file if it's different. If you have other files, you can include those in the offline cache by including their paths in an `assets` key like so:

```html
UpUp.start({
  'content-url': 'index.html',
  assets: ['img/logo.png', 'css/style.css', 'headlines.json'],
});
```

It's important to note that UpUp will only work if you are serving the files from a URL served over HTTPS, so this will only be useful if you're publishing on an actual domain with an SSL certificate.</pre>
<article hidden="true"></article>
<footer>
<time title="Created 2/13/2024, 6:00:18 PM">2/13/2024, 11:21:43 PM</time> <button class="dull editBtn" onclick="edit(1707872418096)">Edit</button>
</footer></section></main>
<script defer>
// Aliases for space savings
const w = window;
w.q = (s, el) => (el ?? document).querySelector(s);
w.qa = (s, el) => (el ?? document).querySelectorAll(s);
w.gebi = i => document.getElementById(i);
w.ce = t => document.createElement(t);
w.main = q('main');
w.nav = q('nav ul');
w.sBar = q('#search input');
w.res = q('#results');
// Get and/or set the URL hash
w.h = hash => (!hash ? true : location.hash = hash) && (!location.hash ? null : decodeURIComponent(location.hash.substring(1)));
// The current page id
w.current = null;
// Get current page Elements as array
w.pages = () => Array.from(qa('main > section'));
// Get page details as object from Element
w.info = el => ({
	id: el.id,
	name: q('h1', el).textContent,
	src: q('pre', el)?.textContent ?? '',
});
// Get the names of all settings form inputs
w.settingFields = () => Array.from(qa('#settings :is(input, textarea, select)[name]')).map(el => el.name);
// Return a nav li element for the given page Element
w.navItem = el => {
	const { id, name } = info(el);
	const li = ce('li');
	li.innerHTML = /*html*/`<a href="javascript:go('${id}')" id="nav${id}">${name}</a>`;
	return li;
};
// Show (default) or hide the given page Element
w.show = (el, y = true) => el.style.display = (y ? 'block' : '');
// Enable typing tab characters in all textarea Elements without class `notab`
w.handleTab = () => {
	qa('textarea:not(.notab)').forEach(t => t.onkeydown = function (e) {
		if (e.key === 'Tab' && !e.shiftKey) {
			const s = this;
			const tab = '\t';
			if (t !== s) s.focus();
			const safeInsert = document.execCommand('insertText', false, tab);
			if (!safeInsert) {
				s.setRangeText(tab, s.selectionStart || 0, s.selectionEnd || 0, 'end');
				s.dispatchEvent(new InputEvent('input', { tab, inputType: 'insertText' }));
			}
			e.preventDefault();
		}
	});
};
// Parse [[wiki links]]
w.wikiLinks = src => src.replace(/\[\[([^\]\|]+)(\|[^\]]+)?\]\]/g, (m, name, text) => `<a href="javascript:go('${name}')">${text ? text.substring(1) : name}</a>`);
// Show page Element with given name or id, or home page if none is given. If back == true, don't update url hash
w.go = (page, back = false) => {
	if (current) edit(current, false);
	const pp = pages();
	pp.forEach(el => show(el, false));
	const pg = gebi(page) ?? pp.find(el => info(el).name === page) ?? pp[0];
	if (pg) {
		const { name } = info(pg);
		document.title = name;
		if (!back) h(name);
		show(pg);
		current = pg.id;
	} else {
		if (!back) location.hash = '';
		else location.replace(location.pathname);
	}
};
// Show (default) or hide settings dialog
w.settings = close => {
	const s = q('#settings');
	if (close === true) return s.close();
	const form = q('form', s);
	settingFields().forEach(n => form[n].value = q('#' + n)?.innerHTML?.trim() ?? '');
	handleTab();
	s.show();
};
// Save the settings dialog & update innerHTML of all elements with ids matching the input name
w.update = form => settingFields().forEach(n => q('#' + n).innerHTML = form[n].value);
// Show (default) or hide a form to edit the page with given id. Also updates nav entry.
w.edit = (id, y = true) => {
	const pg = gebi(id);
	if (pg) {
		const { name, src } = info(pg);
		const eId = `edit${id}`;
		if (!y) {
			const f = q(`#${eId}`);
			render(!f ? null : id); // If the page was re-sorted, re-render everything so nav updates as well
			show(pg);
			if (f) f.parentElement.removeChild(f);
			return;
		}
		go(id);
		show(pg, false);
		const pp = pages();
		const pos = pp.findIndex(p => p.id == id);
		const f = ce('form');
		f.id = eId;
		f.innerHTML = /*html*/`<h1>Edit</h1>
<label>Name <input name="name" value="${name}"></label>
<label>Markdown Content<br><textarea name="text">${src}</textarea></label>
<label>Sort Position <select name="pos">${pp.map((p, i) => `<option${i === pos ? ' selected' : ''}>${i}</option>`).join('')}</select></label>
<footer><button type="submit">Save</button> <button type="button" class="dull" onclick="edit(${id}, false)">Cancel</button> <button type="button" class="bad" onclick="del(${id})">Delete</button></footer>`;
		f.onsubmit = e => {
			e.preventDefault();
			q('h1', pg).textContent = f.name.value.trim();
			q('pre', pg).textContent = f.text.value;
			q('footer>time', pg).textContent = new Date().toLocaleString();
			const newPos = parseInt(f.pos.value);
			if (newPos !== pos) {
				pp.splice(newPos, 0, pp.splice(pos, 1)[0]);
				main.innerHTML = '';
				pp.forEach(p => main.appendChild(p));
			}
			edit(id, false);
		};
		pg.parentElement.insertBefore(f, pg);
		handleTab();
		f.name.focus();
	}
};
// Create a new page Element & start editing
w.add = () => {
	const p = ce('section');
	p.id = Date.now();
	const t = new Date().toLocaleString();
	p.innerHTML = /*html*/`<h1></h1>
<pre hidden></pre>
<article></article>
<footer>
	<time title="Created ${t}">${t}</time> <button class="dull editBtn" onclick="edit(${p.id})">Edit</button>
</footer>`;
	main.appendChild(p);
	nav.appendChild(navItem(p));
	edit(p.id);
};
// Delete the page with the given id
w.del = id => {
	if (confirm('Delete page?')) {
		const p = gebi(id);
		if (p) p.parentElement.removeChild(p);
		const na = gebi(`nav${id}`);
		if (na) na.closest('ul').removeChild(na.parentElement);
		const e = gebi(`edit${id}`);
		if (e) e.parentElement.removeChild(e);
		go();
	}
};
// Check all pages for text matching the given term
w.search = term => {
	clearTimeout(res.debounce);
	res.debounce = setTimeout(() => {
		res.innerHTML = '';
		if (!term) return;
		const lcTerm = term.toLowerCase();
		pages().map(p => {
			const i = info(p);
			const tmp = ce('div');
			tmp.innerHTML = md(wikiLinks(i.src));
			i.txt = `${i.name} ${tmp.textContent}`;
			return i;
		})
			// Get only pages that contain the search term anywhere in any form
			.filter(({txt}) => txt.match(new RegExp(term, 'i')) !== null)
			// Compare index of literal text plus case-insensitive text
			.sort((a, b) => {
				const ai = a.txt.indexOf(term);
				let aici = a.txt.toLowerCase().indexOf(lcTerm);
				if (aici < 0) aici = Infinity;
				const bi = b.txt.indexOf(term);
				let bici = b.txt.toLowerCase().indexOf(lcTerm);
				if (bici < 0) bici = Infinity;
				if (ai >= 0 && bi < 0) return -1;
				if (ai < 0 && bi >= 0) return -1;
				if (ai < 0 && bi < 0) {
					if (aici === bici) return 0;
					return aici < bici ? -1 : 1;
				}
				if (ai === bi) return 0;
				return ai < bi ? -1 : 1;
			})
			// Repopulate search responses el with term highlighted
			.forEach((p) => {
				const mark = t => t.replace(new RegExp(`(${term.replace(/[\W\D]/g, '\\$&')})`, 'i'), '<mark>$1</mark>');
				const txt = p.txt.replace(p.name, '');
				const i = txt.toLowerCase().indexOf(lcTerm);
				const preview = txt.length < 1 ? '' : txt.substring(Math.max(0, i - 10), Math.min(100, txt.length, i + term.length + 10));
				res.innerHTML += /*html*/`<a href="javascript:go(${p.id})" onclick="res.innerHTML = ''">${mark(p.name)}<p class="sm">${mark(preview)}</p></a>`;
			});
	}, 300);
};
// If page id given, re-render stored Markdown directly into the element & update nav text
w.render = (pId = null) => {
	if (!pId) nav.innerHTML = '';
	(!pId ? pages() : [gebi(pId)]).forEach(p => {
		const { id, name, src } = info(p);
		q('pre', p).setAttribute('hidden', '');
		const a = q('article', p);
		a.innerHTML = md(wikiLinks(src));
		a.removeAttribute('hidden');
		if (!pId) {
			nav.appendChild(navItem(p));
		} else {
			gebi(`nav${id}`).textContent = name;
		}
	});
};
// Reset to default state, remove rendered Markdown, start download of HTML file, and reset to current view.
w.save = () => {
	go(); // go to home page
	const pp = pages();
	sBar.value = '';
	res.innerHTML = '';
	pp.forEach(p => {
		const txt = q('pre', p).removeAttribute('hidden');
		const a = q('article', p);
		a.setAttribute('hidden', true);
		a.innerHTML = '';
		const edit = gebi(`edit${p.id}`);
		if (edit) edit.parentElement.removeChild(edit);
	});
	const name = q('#wiki #name').textContent;
	document.title = name;
	const html = /*html*/`<!DOCTYPE html><html lang="en">
<head>${document.head.innerHTML}</head>
<body>${document.body.innerHTML}</body></html>`;
	render();
	history.back();
	// Create & click anchor tag with download attribute
	const a = ce('a');
	a.setAttribute('href', 'data:text/html;charset=utf-8,' + encodeURIComponent(html));
	const filename = name.toLowerCase().replace(/\W/g, '_') + '.html';
	a.setAttribute('download', filename);
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
};

// Use save function if Ctrl+S is used
w.addEventListener('keydown', e => {
	if ((e.ctrlKey || e.metaKey) && e.key === 's' && !e.shiftKey) {
		e.preventDefault();
		save();
	}
});
// Ensure correct page displays when Back button is pressed.
w.addEventListener('popstate', e => {
	go(h(), true);
});
// Trigger search on input and focus of search bar
['input', 'focus'].forEach(e => sBar.addEventListener(e, ({ target }) => search(target.value)));

// Initialize the view
(() => {
	render();
	go(h());
})();

/**
 * Markdown parser modified beyond recognition from md.js <https://github.com/thysultan/md.js>
 * @licence MIT
 * Supported Features:
 * - HTML
 * - headings h1–h6+ (# h1, ## h2, ### h3, etc.)
 * - paragraphs (\n\n)
 * - line breaks (	\n)
 * - blockquotes (> text)
 * - horizontal rule (---, ***, - - -, * * *)
 * - code blocks (```)
 * - inline code (`code`)
 * - images with alt text & optional title (![alt](image_src "optional title"))
 * - inline Markdown links with optional title ([link text](link_url "optional title"))
 * - auto links & email linking (<http://url.domain>, <person@email.example>)
 * - lists with indentation (- list item, * list item, + list item)
 * - checkboxes ([ ], [x])
 * - bold, italic (**bold**, __bold__, *italic*, _italic_, ***bold & italic***, ___bold & italic___, **_bold & italic_**, etc.)
 * - strikethrough (~~strikethrough~~)
 * - escaped characters (\*, \_)
 * 
 * @param	{string} src
 * @return {string}
 */
function md(src) {
	if (!src) return '';

	const chr = {
		'<': '&lt;',
		'>': '&gt;',
		'"': '&quot;',
		"'": '&#39;',
		'&': '&amp;',
		'[': '&#91;',
		']': '&#93;',
		'(': '&#40;',
		')': '&#41;',
		'_': '&#95;',
		'*': '&ast;',
		'`': '&#96;',
	};
	// Save non-& char map values without `&` to more easily check for double-escaped htmlEntity values
	const esc2 = Object.keys(chr).filter(c => c != '&').map(c => chr[c].replace(c != '&' ? '&' : '', ''));

	// Get the HTML entity for the character from the char map
	const ent = str => str.replace(/[<>&\(\)\[\]"']/g, c => (chr[c] || c))
		.replace(new RegExp(`&amp;(${esc2.join('|')})`, 'g'), '&$1');

	var code = []; // Code Blocks
	var cIdx = 0; // Code index
	var html = []; // HTML tags
	var hIdx = 0; // HTML index
	
	// to allow matching trailing paragraphs
	var l = src.length;
	if (src[l - 1] !== '\n' && src[l - 2] !== '\n') {
		src += '\n\n';
	}

	// escaped characters
	src = src.replace(/\\(.)/g, (m, c) => (chr[c] || m))
		// collect code blocks and replace with placeholder
		// we do this to avoid code blocks matching the paragraph regexp
		.replace(/```(.*)\n([^\0]+?)```(?!```)/gm, (m, lang, block) => {
			code[cIdx] = { lang, block: ent(block) };
			return `{code-${cIdx++}}`;
		})
		// inline code
		.replace(/`([^`]+?)`/g, (m, c) => `<code>${ent(c)}</code>`)
		// auto links
		.replace(/<([^>\s]+(\/\/|@)[^>\s]+)>/g, (m, url, method) => `[${url}](${method === '@' ? 'mailto:' : ''}${url})`)
		// links
		.replace(/(!?)\[([^\]]*?)\]\(([^\s\n]*)(?:| "(.*)")\)/gm, (m, img, txt, url, title) => {
			txt = ent(txt);
			// try to decode url before re-encoding it in case it has encoded values to prevent encoding the % character
			try { url = decodeURI(url); } catch { } // using try/catch because a malformed URI throws an error
			url = encodeURI(url);
			title = title ? ` title="${ent(title)}"` : '';
			if (img) return `<img src="${url}" alt="${txt}"${title}>`;
			return `<a href="${url}"${title}>${txt}</a>`;
		})
		// HTML tags
		.replace(/(<\/?[a-zA-Z]+[^>]*>)/gm, (m, tag) => {
			html[hIdx] = tag;
			return `{html-${hIdx++}}`;
		})
		// blockquotes
		.replace(/^[ \t]*>+ (.*)/gm, '<blockquote>\n$1\n</blockquote>')
		.replace(/(<\/blockquote>\n?<blockquote>)+?/g, '')
		// headings
		.replace(/^(#+) +(.*)/gm, (m, hash, txt) => `<h${hash.length}>${txt}</h${hash.length}>`)
		// headings h1 (commonmark)
		.replace(/^([^\n\t ])(.*)\n====+/gm, '<h1>$1$2</h1>')
		// headings h2 (commonmark)
		.replace(/^([^\n\t ])(.*)\n----+/gm, '<h2>$1$2</h2>')
		// horizontal rule 
		.replace(/\n( *[-*]){3,}\n/gm, '<hr>')
		// checkboxes
		.replace(/\[( |x)\]/g, (m, checked) => `<input type="checkbox" disabled${checked.toLowerCase() === 'x' ? ' checked' : ''}>`)
		// line breaks
		.replace(/	+\n/gm, '<br>')
		// paragraphs - exclude lists, already-rendered HTML, & whitespace
		.replace(/^([^-\+\*\d<\t \n])([^]*?)(?:\n\n)/gm, (m, leadChr, body) => `<p>${leadChr}${body}</p>\n`)
		// lists
		.replace(/^([\t ]*)(?:(-|\+|\*)|(\d+(?:\)|\.))) (.*)/gm, (m, lead, b, numbered, txt) => {
			lead = lead.replace(/	/g, '\t');
			const type = numbered ? 'o' : 'u';
			return `${lead}<${type}l><li>${txt}</li></${type}l>`;
		});

	// This handles *almost* all combinations, but some indented lists combining ul & ol don't render right
	var indentRE = /<\/li><\/(u|o)l>\n(\t+)<(u|o)l><li>(.*)<\/li><\/(u|o)l>/;
	while (src.match(indentRE)) {
		src = src.replace(indentRE, (m, pEnd, tabs, cStart, txt, cEnd) => {
			if (tabs.length > 0) {
				tabs = tabs.substring(1);
				if (tabs.length > 0) tabs = '\n' + tabs;
			}
			return `${tabs}<${cStart}l><li>${txt}</li></${cEnd}l></li></${pEnd}l>`;
		});
	}

	// Combine lists
	src = src.replace(/(<\/ul>\n?[ \t]*<ul>)+?/g, '')
		.replace(/(<\/ol>\n?[ \t]*<ol>)+?/g, '')
		// strong
		.replace(/\*\*([^\n*]+?)\*\*/g, '<strong>$1</strong>')
		.replace(/__([^\n_]+?)__/g, '<strong>$1</strong>')
		// emphasis
		.replace(/\*([^\n*]+?)\*/g, '<em>$1</em>')
		.replace(/_([^\n_]+?)_/g, '<em>$1</em>')
		// strike through
		.replace(/(?:~~)([^~]+?)(?:~~)/g, '<del>$1</del>');

	// replace html tag placeholders
	for (let i = 0; i < hIdx; i++) {
		src = src.replace(`{html-${i}}`, html[i]);
	}

	// replace code block placeholders
	for (let i = 0; i < cIdx; i++) {
		const { lang, block } = code[i];
		src = src.replace(
			`{code-${i}}`,
			`<pre><code${lang ? ` class="language-${lang}"` : ''}>${ent(block)}</code></pre>`
		);
	}

	return src.trim();
}
</script>
</body></html>