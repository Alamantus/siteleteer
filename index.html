<!DOCTYPE html><html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>javascript:app.go()</title>
<style id="css">:root {
	--text: #000;
	--font: serif;
	--size: 12pt;
	--space: 0.5rem;
	--bg: cornsilk;
	--accent1: olivedrab;
	--accent2: rebeccapurple;
	--dull: bisque;
	--bad: tomato;
	--button-border: none;
	--rounded: 3px;
	--max-width: 1200px;
}
* {
	font-family: var(--font);
	color: var(--text);
	font-size: var(--size);
	line-height: 1.15em;
	background-color: transparent;
}
* * {
	font-family: inherit;
	color: inherit;
	font-size: inherit;
	font-weight: inherit;
	line-height: inherit;
}
*[hidden],
dialog:not([open]),
main>section,
#searchResults:empty {
	display: none;
}
dialog[open] {
	display: block;
	background: var(--bg);
}
html {
	background-color: var(--bg);
}
body {
	background: transparent;
}
body>header,
#settings {
	padding: var(--space) 0.25rem;
	width: 100%;
	max-width: var(--max-width);
}
main {
	padding: var(--space);
	max-width: var(--max-width);
}
nav ul li a:empty::after,
main:empty::after,
main>section article:empty::after {
	content: "No content";
}
main>section>header>h1,
form h1 {
	margin: 0 0 var(--space);
}
*+* {
	margin: var(--space) 0 0;
}
main>section+section {
	margin: 0;
}
#wiki a,
#wiki a * {
	color: var(--accent1);
}
#wiki #desc {
	margin-left: var(--space);
}
#actions {
	display: flex;
	gap: var(--space);
	align-items: center;
}
h1 {
	font-size: 2.2rem;
}
h2 {
	font-size: 1.8rem;
}
h3,
#wiki #name {
	font-size: 1.5rem;
}
h4 {
	font-size: 1.15rem;
}
h1,
h2,
h3,
h4,
h5,
#wiki #name {
	font-weight: bold;
}
h5,
h6 {
	font-style: italic;
}
h6 {
	font-weight: normal;
}
a {
	color: var(--accent2);
}
button {
	background-color: var(--accent1);
	color: white;
	border: var(--button-border);
	border-radius: var(--rounded);
	padding: 0.25rem 0.5rem;
	cursor: pointer;
	font-weight: 500;
}
button.other {
	background-color: var(--accent2);
}
button.dull {
	background-color: var(--dull);
	font-weight: normal;
	color: var(--text);
}
button.bad {
	background-color: var(--bad);
}
label {
	display: block;
	font-weight: 500;
}
input,
textarea,
select,
option {
	border-radius: 0px;
	padding: var(--space);
	background: var(--bg);
	border: 1px solid var(--text);
	border-radius: var(--rounded);
}
textarea {
	height: 300px;
	width: 100%;
	max-width: 600px;
}
nav ul {
	margin: var(--space) 0;
	padding: var(--space) 0;
	border-top: 1px solid var(--text);
	list-style: none;
}
nav ul li {
	display: inline-block;
	margin: var(--space);
}
.sm {
	font-size: 0.8em;
}
#searchBar {
	position: relative;
}
#searchResults {
	position: absolute;
	background: var(--bg);
	border: 1px solid #000;
	top: calc(var(--size) + .5rem + 2px);
	left: 0;
	width: 100%;
	max-height: 300px;
	overflow-y: auto;
	overflow-x: hidden;
	padding: 3px;
	border-radius: 3px;
	z-index: 10;
}
#searchResults a {
	display: block;
	box-sizing: border-box;
	width: 100%;
	padding: 6px 10px;
	margin: 2px 0;
	color: #000;
}
#searchResults a:hover {
	color: #fff;
	background: var(--accent2);
}
mark {
	background: var(--accent1);
	color: white;
}
main>section>footer>time {
	cursor: help;
}
main>section>footer>time::before {
	content: 'Updated ';
}</style>
</head>
<body>
<header>
	<section id="wiki">
		<a href="javascript:app.go()" id="name">SkeleWiki</a>
		<span id="desc">A <em>dead</em> simple tool to make bare <em>bones</em> multi-page websites in a single HTML file.</span>
	</section>
	<section id="actions">
		<div id="searchBar" style="flex:1">
			<label>
				<strong>Search</strong> <input type="search" oninput="app.search(event.target.value)">
			</label>
			<div id="searchResults"></div>
		</div>
		<div style="flex:2;text-align:right">
			<button id="settingsButton" class="dull" onclick="app.settings()">Settings</button>
			<button id="newPageButton" class="other" onclick="app.add()">New Page</button>
			<button id="saveButton" onclick="app.save()">Save</button>
		</div>
	</section>
	<nav>
		<ul><li><a href="javascript:app.go('1707517025349')" id="nav1707517025349">About SkeleWiki</a></li><li><a href="javascript:app.go('1707517176500')" id="nav1707517176500">Markdown Support</a></li><li><a href="javascript:app.go('1707517259013')" id="nav1707517259013">Hacking SkeleWiki</a></li></ul>
	</nav>
</header>
<dialog id="settings">
	<h1>Settings</h1>
	<form method="dialog" onsubmit="app.update(event.target)">
		<label>
			Wiki Name<br>
			<input name="name">
		</label>
		<label>
			Wiki Description<br>
			<input name="desc">
		</label>
		<label>
			Wiki CSS<br>
			<textarea name="css"></textarea>
		</label>
		<footer>
			<button type="submit">Save</button>
			<button type="button" class="dull" onclick="app.settings(true)">Cancel</button>
		</footer>
	</form>
</dialog>
<main><section id="1707517025349" style="display: block;"><header><h1>About SkeleWiki</h1></header><pre hidden="">SkeleWiki is a super hackable, self-replicating web app that lets you create inter-linking pages formatted with Markdown. All data created with SkeleWiki is simply stored directly as HTML on the page, and the code within the HTML file is not minified at all, making it easier to simply crack open in a text editor and modify however you wish!

It's page management with Markdown formatting and a simple search bar all rolled up into a single HTML file that's _less than 32 kilobytes!_

## How to Use

Just download the HTML file and open it in a browser to get started. It's pretty simple:

- Use the "Settings" button to change the wiki's name, description, and CSS, then push "Save" to make your changes.
- Create a new page by using the "New Page" button. This will create an empty page that you can start editing right away.
  - Set a page title in the "Name" field and write some text for the page with Markdown formatting.
    - In addition to Markdown, you can link between pages using wiki link format by putting the (case insensitive) page name in 2 square braces \[\[like this\]\]! If you want the link to have different text than the page's name, then put the page name first then the text to display after a vertical bar \[\[other page|like this\]\]!
  - If you have multiple pages, you can change the order they display in the navigation by changing the Sort Position.
  - The page in the `0` position will be the "home" page of your SkeleWiki that is displayed when the file loads or when the Wiki Title is clicked.
  - Use "Save" to save the page and view the page.
  - Use "Cancel" to prevent any changes from being saved (results in an empty page if it's newly created).
  - Use "Delete" to remove the page and navigation entry.
- Search for text in your pages using the Search bar. Check the Particularities below for exactly how the results are found &amp; sorted.
- Click the "Edit" button at the bottom of a page to change that page. The date at the bottom of the page will be updated when you save your changes.
- Save your changes to a new HTML file by using the "Save" button (or &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;S&lt;/kbd&gt;). The HTML file defaults to a lowercase version of your wiki's name with any non-alphanumeric characters converted to underscores `like_this.html`.

And that's pretty much it!

### Particularities

- New pages are always added to the end of the page order, and thus the end of the nav bar.
- Pages without a name cannot be linked to and display in the navigation as "No content."
- Navigating to a different page while editing will change the page _immediately_ and **discard any unsaved changes** to the page.
- When editing a page, pressing &lt;kbd&gt;Tab&lt;/kbd&gt; in the Markdown Content text area (also the Wiki CSS text area in Settings) will type a `Tab` character instead of changing focus to the next form element.
- You _can_ use HTML in the wiki name and description, but should you?
- The Wiki CSS is actually the literal contents of the `&lt;style&gt;` tag in the HTML's head. You can change it however you wish, but it might affect the wiki's page structure if you remove too much stuff.
- Every page exists in the file's HTML, but all pages except for the current one are hidden by default.
- The "Updated" timestamp at the bottom of a page is set to _your_ local date and time.
- Hover over the "Updated" timestamp at the bottom of a page to see the timestamp of when the page was first created, i.e. the moment "New Page" was pressed.
- Search prioritizes exact matches over case-insensitive ones and will display matching pages in order by where the match is found, prioritizing page names over page text, and only the text content of the parsed Markdown is searched when looking for results within the page text.
- Very large amounts of content on a page and very large numbers of pages may affect the performance of your SkeleWiki because it just uses and manipulates the raw DOM.
- Only the Markdown of each page is saved and can be found directly in the HTML file within a `pre` tag in the page's `section` tag. It's parsed into formatted HTML that displays when the page is loaded and the JavaScript runs.
- All pages are on the same level and display in the wiki nav bar.</pre><article><p>SkeleWiki is a super hackable, self-replicating web app that lets you create inter-linking pages formatted with Markdown. All data created with SkeleWiki is simply stored directly as HTML on the page, and the code within the HTML file is not minified at all, making it easier to simply crack open in a text editor and modify however you wish!</p>
<p>It's page management with Markdown formatting and a simple search bar all rolled up into a single HTML file that's <em>less than 32 kilobytes!</em></p>
<h2>How to Use</h2>

<p>Just download the HTML file and open it in a browser to get started. It's pretty simple:</p>
<ul><li>Use the "Settings" button to change the wiki's name, description, and CSS, then push "Save" to make your changes.</li><li>Create a new page by using the "New Page" button. This will create an empty page that you can start editing right away.</li><li>Set a page title in the "Name" field and write some text for the page with Markdown formatting.</li><li>In addition to Markdown, you can link between pages using wiki link format by putting the (case insensitive) page name in 2 square braces [[like this]]! If you want the link to have different text than the page's name, then put the page name first then the text to display after a vertical bar [[other page|like this]]!</li><li>If you have multiple pages, you can change the order they display in the navigation by changing the Sort Position.</li><li>The page in the <code>0</code> position will be the "home" page of your SkeleWiki that is displayed when the file loads or when the Wiki Title is clicked.</li><li>Use "Save" to save the page and view the page.</li><li>Use "Cancel" to prevent any changes from being saved (results in an empty page if it's newly created).</li><li>Use "Delete" to remove the page and navigation entry.</li><li>Search for text in your pages using the Search bar. Check the Particularities below for exactly how the results are found &amp; sorted.</li><li>Click the "Edit" button at the bottom of a page to change that page. The date at the bottom of the page will be updated when you save your changes.</li><li>Save your changes to a new HTML file by using the "Save" button (or <kbd>Ctrl</kbd>+<kbd>S</kbd>). The HTML file defaults to a lowercase version of your wiki's name with any non-alphanumeric characters converted to underscores <code>like_this.html</code>.</li></ul>

<p>And that's pretty much it!</p>
<h3>Particularities</h3>

<ul><li>New pages are always added to the end of the page order, and thus the end of the nav bar.</li><li>Pages without a name cannot be linked to and display in the navigation as "No content."</li><li>Navigating to a different page while editing will change the page <em>immediately</em> and <strong>discard any unsaved changes</strong> to the page.</li><li>When editing a page, pressing <kbd>Tab</kbd> in the Markdown Content text area (also the Wiki CSS text area in Settings) will type a <code>Tab</code> character instead of changing focus to the next form element.</li><li>You <em>can</em> use HTML in the wiki name and description, but should you?</li><li>The Wiki CSS is actually the literal contents of the <code>&lt;style&gt;</code> tag in the HTML's head. You can change it however you wish, but it might affect the wiki's page structure if you remove too much stuff.</li><li>Every page exists in the file's HTML, but all pages except for the current one are hidden by default.</li><li>The "Updated" timestamp at the bottom of a page is set to <em>your</em> local date and time.</li><li>Hover over the "Updated" timestamp at the bottom of a page to see the timestamp of when the page was first created, i.e. the moment "New Page" was pressed.</li><li>Search prioritizes exact matches over case-insensitive ones and will display matching pages in order by where the match is found, prioritizing page names over page text, and only the text content of the parsed Markdown is searched when looking for results within the page text.</li><li>Very large amounts of content on a page and very large numbers of pages may affect the performance of your SkeleWiki because it just uses and manipulates the raw DOM.</li><li>Only the Markdown of each page is saved and can be found directly in the HTML file within a <code>pre</code> tag in the page's <code>section</code> tag. It's parsed into formatted HTML that displays when the page is loaded and the JavaScript runs.</li><li>All pages are on the same level and display in the wiki nav bar.</li></ul></article><footer><time title="Created 2/9/2024, 3:17:05 PM">2/9/2024, 3:20:57 PM</time> <button class="dull editButton" onclick="app.edit(1707517025349)">Edit</button></footer></section><section id="1707517176500" style=""><header><h1>Markdown Support</h1></header><pre hidden="">Click the "Edit" button at the bottom of the page to see the markdown source!

---

&lt;!--This means we can use HTML elements in Markdown, such as the comment
element, and they won't be affected by a markdown parser. However, if you
create an HTML element in your markdown file, you cannot use markdown syntax
within that element's contents.--&gt;

# This is an `&lt;h1&gt;`
## This is an `&lt;h2&gt;`
### This is an `&lt;h3&gt;`
#### This is an `&lt;h4&gt;`
##### This is an `&lt;h5&gt;`
###### This is an `&lt;h6&gt;`

This is an h1
=============

This is an h2
-------------

*This text is in italics.*
_And so is this text._

**This text is in bold.**
__And so is this text.__

***This text is in both.***
**_As is this!_**
*__And this!__*

~~This text is rendered with strikethrough.~~

This is a paragraph. I'm typing in a paragraph isn't this fun?

Now I'm in paragraph 2.
I'm still in paragraph 2 too!


I'm in paragraph three!

I end with two spaces (highlight me to see them).

There's a `&lt;br /&gt;`  
above me!

&gt; This is a block quote. You can either
&gt; manually wrap your lines and put a `&gt;` before every line or you can let your lines get really long and wrap on their own.
&gt; It doesn't make a difference so long as they start with a `&gt;`.

&gt; You can only use one level
&gt;&gt; of indentation?
&gt;&gt; Oh well!

* Item
* Item
* Another item

or

+ Item
+ Item
+ One more item

or

- Item
- Item
- One last item

- List
  - Indentation
    - also
  - works!
- (with
  - two
  - spaces)

1. Item one
2. Item two
3. Item three

1. Item one
1. Item two
1. Item three

1. Item one
2. Item two
3. Item three
  * mixing
  * Sub-list types
4. Item four

Boxes below without the 'x' are unchecked HTML checkboxes.
- [ ] First task to complete.
- [ ] Second task that needs done

This checkbox below will be a checked HTML checkbox.

- [x] This task has been completed

```
This is code
        So is this
```

```javascript
function canLabelCode() {
    return true;
}
```

\`\`\`
Here's some \&lt;Escaped text!\&gt;
\`\`\`

John didn't even know what the `go_to()` function did!

***

---

- - -

****************

[Click me!](http://test.com/)

[Click me!](http://test.com/ "Link to Test.com")

[Go to music](/music/).

- [Heading](#heading)
- [Another heading](#another-heading)
- [Chapter](#chapter)
  - [Subchapter &lt;h3 /&gt;](#subchapter-h3-)

![This is the alt-attribute for my image](http://imgur.com/myimage.jpg "An optional title")

&lt;http://testwebsite.com/&gt; is equivalent to
[http://testwebsite.com/](http://testwebsite.com/)

&lt;foo@bar.com&gt;

I want to type *this text surrounded by asterisks* but I don't want it to be
in italics, so I do this: \*this text surrounded by asterisks\*.

Your computer crashed? Try sending a
&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;</pre><article><p>Click the "Edit" button at the bottom of the page to see the markdown source!
</p><hr>
<!--This means we can use HTML elements in Markdown, such as the comment
element, and they won't be affected by a markdown parser. However, if you
create an HTML element in your markdown file, you cannot use markdown syntax
within that element's contents.--><p></p>
<h1>This is an <code>&lt;h1&gt;</code></h1>
<h2>This is an <code>&lt;h2&gt;</code></h2>
<h3>This is an <code>&lt;h3&gt;</code></h3>
<h4>This is an <code>&lt;h4&gt;</code></h4>
<h5>This is an <code>&lt;h5&gt;</code></h5>
<h6>This is an <code>&lt;h6&gt;</code></h6>

<h1>This is an h1</h1>

<h2>This is an h2</h2>

<em>This text is in italics.</em>
<p><em>And so is this text.</em></p>
<strong>This text is in bold.</strong>
<p><strong>And so is this text.</strong></p>
<em><strong>This text is in both.</strong></em>
<strong><em>As is this!</em></strong>
<em><strong>And this!</strong></em>

<p><del>This text is rendered with strikethrough.</del></p>
<p>This is a paragraph. I'm typing in a paragraph isn't this fun?</p>
<p>Now I'm in paragraph 2.
I'm still in paragraph 2 too!</p>

<p>I'm in paragraph three!</p>
<p>I end with two spaces (highlight me to see them).</p>
<p>There's a <code>&lt;br /&gt;</code>  
above me!</p>
<blockquote>
<p>This is a block quote. You can either</p>
<p>manually wrap your lines and put a <code>&gt;</code> before every line or you can let your lines get really long and wrap on their own.</p>
<p>It doesn't make a difference so long as they start with a <code>&gt;</code>.
</p></blockquote><p></p>
<blockquote>
<p>You can only use one level</p>
<p>of indentation?</p>
<p>Oh well!
</p></blockquote><p></p>
<ul><li>Item</li><li>Item</li><li>Another item</li></ul>

<p>or</p>
<ul><li>Item</li><li>Item</li><li>One more item</li></ul>

<p>or</p>
<ul><li>Item</li><li>Item</li><li>One last item</li></ul>

<ul><li>List</li><li>Indentation</li><li>also</li><li>works!</li><li>(with</li><li>two</li><li>spaces)</li></ul>

<ol><li>Item one</li><li>Item two</li><li>Item three</li></ol>

<ol><li>Item one</li><li>Item two</li><li>Item three</li></ol>

<ol><li>Item one</li><li>Item two</li><li>Item three</li></ol>
  <ul><li>mixing</li><li>Sub-list types</li></ul>
<ol><li>Item four</li></ol>

<p>Boxes below without the 'x' are unchecked HTML checkboxes.
</p><ul><li><input type="checkbox" disabled=""> First task to complete.</li><li><input type="checkbox" disabled=""> Second task that needs done<p></p></li></ul>
<p>This checkbox below will be a checked HTML checkbox.</p>
<ul><li><input type="checkbox" disabled="" checked=""> This task has been completed</li></ul>

<p></p><pre><code>This is code
        So is this
</code></pre><p></p>
<p></p><pre><code class="language-javascript">function canLabelCode() {
    return true;
}
</code></pre><p></p>
<p>```
Here's some &lt;Escaped text!&gt;
```</p>
<p>John didn't even know what the <code>go_to()</code> function did!
</p><hr><hr><hr><hr>
<a href="http://test.com/">Click me!</a><p></p>
<p><a href="http://test.com/" title="Link to Test.com">Click me!</a></p>
<p><a href="/music/">Go to music</a>.</p>
<ul><li><a href="#heading">Heading</a></li><li><a href="#another-heading">Another heading</a></li><li><a href="#chapter">Chapter</a></li><li><a href="#subchapter-h3-">Subchapter &lt;h3 /&gt;</a></li></ul>

<p><img src="http://imgur.com/myimage.jpg" alt="This is the alt-attribute for my image" title="An optional title"></p>
<p><a href="http://testwebsite.com/">http://testwebsite.com/</a> is equivalent to
<a href="http://testwebsite.com/">http://testwebsite.com/</a></p>
<p><a href="mailto:foo@bar.com">foo@bar.com</a></p>
<p>I want to type <em>this text surrounded by asterisks</em> but I don't want it to be
in italics, so I do this: *this text surrounded by asterisks*.</p>
<p>Your computer crashed? Try sending a
<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></p></article><footer><time title="Created 2/9/2024, 3:19:36 PM">2/9/2024, 3:20:16 PM</time> <button class="dull editButton" onclick="app.edit(1707517176500)">Edit</button></footer></section><section id="1707517259013" style=""><header><h1>Hacking SkeleWiki</h1></header><pre hidden="">Since it's literally just an HTML file with all its code visibly formatted in the way the developer writes it, you can just change the content or behavior! All you need is a text editor and a basic understanding of web development (HTML, CSS, and JavaScript).

The only HTML altered by the app is:

- The `&lt;a id="name"&gt;` element in the wiki header
- The `&lt;span id="desc"&gt;` element in the wiki header
- The CSS within the `&lt;style id="css"&gt;` element in the HTML `head`
- The HTML content within the `&lt;main&gt;` element.

Pretty much anywhere else is untouched by the JavaScript and can be modified. If you need to add meta tags to the head or additional code, you can just do that. In addition, all the app functions can be accessed through `window` in JavaScript under the `app` Object. There are also a couple global helper methods in there to keep the code small.

### Ideas

- Don't want your updated time visible on a page? Find the `main&gt;section&gt;footer&gt;time` entry in the Wiki CSS and add `display: none;` to hide it.
  - Don't want it in the HTML at all? Then you'll need to update the code to stop the `&lt;time&gt;` elements from being created and then remove them from your HTML. It's set in the `app.add()` method and modified in the `app.edit()` method.
- Need SkeleWiki in your own language? Just modify the UI text in the HTML file!
- Want to restructure the whole app? You can change the CSS and HTML completely if you need to! Just check the code for any expected structure patterns first so you don't break anything.
- Don't like the Markdown parser? Replace it! As long as whatever parser you use has its parse function set to `window.md()`, SkeleWiki should handle it fine!</pre><article><p>Since it's literally just an HTML file with all its code visibly formatted in the way the developer writes it, you can just change the content or behavior! All you need is a text editor and a basic understanding of web development (HTML, CSS, and JavaScript).</p>
<p>The only HTML altered by the app is:</p>
<ul><li>The <code>&lt;a id="name"&gt;</code> element in the wiki header</li><li>The <code>&lt;span id="desc"&gt;</code> element in the wiki header</li><li>The CSS within the <code>&lt;style id="css"&gt;</code> element in the HTML <code>head</code></li><li>The HTML content within the <code>&lt;main&gt;</code> element.</li></ul>

<p>Pretty much anywhere else is untouched by the JavaScript and can be modified. If you need to add meta tags to the head or additional code, you can just do that. In addition, all the app functions can be accessed through <code>window</code> in JavaScript under the <code>app</code> Object. There are also a couple global helper methods in there to keep the code small.</p>
<h3>Ideas</h3>

<ul><li>Don't want your updated time visible on a page? Find the <code>main&gt;section&gt;footer&gt;time</code> entry in the Wiki CSS and add <code>display: none;</code> to hide it.</li><li>Don't want it in the HTML at all? Then you'll need to update the code to stop the <code>&lt;time&gt;</code> elements from being created and then remove them from your HTML. It's set in the <code>app.add()</code> method and modified in the <code>app.edit()</code> method.</li><li>Need SkeleWiki in your own language? Just modify the UI text in the HTML file!</li><li>Want to restructure the whole app? You can change the CSS and HTML completely if you need to! Just check the code for any expected structure patterns first so you don't break anything.</li><li>Don't like the Markdown parser? Replace it! As long as whatever parser you use has its parse function set to <code>window.md()</code>, SkeleWiki should handle it fine!</li></ul></article><footer><time title="Created 2/9/2024, 3:20:59 PM">2/9/2024, 3:21:19 PM</time> <button class="dull editButton" onclick="app.edit(1707517259013)">Edit</button></footer></section></main>
<script defer="">(() => {
		const w = window;
		w.q = (s, e) => (e ?? document).querySelector(s);
		w.qa = (s, e) => (e ?? document).querySelectorAll(s);
		w.gebi = i => document.getElementById(i);
		w.ce = t => document.createElement(t);
		w.main = q('main');
		w.nav = q('nav ul');
		w.h = (hash) => (!hash ? true : location.hash = hash) && (!location.hash ? null : decodeURIComponent(location.hash.substring(1)));

		w.app = {
			current: null,
			pages: () => Array.from(qa('main > section')),
			info: (el) => ({
				id: el.id,
				name: q('h1', el).textContent,
				src: q('pre', el)?.textContent ?? '',
			}),
			show: (el, y = true) => el.style.display = y ? 'block' : '',
			settingFields: () => Array.from(qa('#settings :is(input, textarea, select)[name]')).map(el => el.name),
			handleTab: () => {
				qa('textarea:not(.notab)').forEach(t => t.onkeydown = function (e) {
					if (e.key === 'Tab') {
						const s = this;
						const tab = '\t';
						if (t !== s) s.focus();
						const safeInsert = document.execCommand('insertText', false, tab);
						if (!safeInsert) {
							s.setRangeText(tab, s.selectionStart || 0, s.selectionEnd || 0, 'end');
							s.dispatchEvent(new InputEvent('input', { tab, inputType: 'insertText' }));
						}
						e.preventDefault();
					}
				});
			},
			navItem(el) {
				const { id, name } = app.info(el);
				const li = ce('li');
				li.innerHTML = /*html*/`<a href="javascript:app.go('${id}')" id="nav${id}">${name}</a>`;
				return li;
			},
			go(page, back = false) {
				if (app.current) app.edit(app.current, false);
				const pp = app.pages();
				pp.forEach(el => app.show(el, false));
				const pg = gebi(page) ?? pp.find(el => app.info(el).name === page) ?? pp[0];
				if (pg) {
					const { name } = app.info(pg);
					document.title = name;
					if (!back) h(name);
					app.show(pg);
					app.current = pg.id;
				} else {
					if (!back) location.hash = '';
					else location.replace(location.pathname);
				}
			},
			settings(close = false) {
				const s = q('#settings');
				if (close) {
					s.close();
					return;
				}
				const form = q('form', s);
				app.settingFields().forEach(k => {
					form[k].value = q('#' + k)?.innerHTML?.trim() ?? '';
				});
				app.handleTab();
				s.show();
			},
			update(form) {
				app.settingFields().forEach(k => {
					q('#' + k).innerHTML = form[k].value;
				});
			},
			edit(id, y = true) {
				const pg = gebi(id);
				if (pg) {
					const { name, src } = app.info(pg);
					const eId = `edit${id}`;
					if (!y) {
						const form = q(`#${eId}`);
						app.render(!form ? null : id); // If the page was re-sorted, re-render everything so nav updates as well
						app.show(pg);
						if (form) form.parentElement.removeChild(form);
						return;
					}
					app.go(id);
					app.show(pg, false);
					const pages = app.pages();
					const sort = pages.findIndex(p => p.id == id);
					const form = ce('form');
					form.id = eId;
					form.innerHTML = /*html*/`<h1>Edit</h1>
<label>Name <input name="name" value="${name}"></label>
<label>Markdown Content<br><textarea name="text">${src}</textarea></label>
<label>Sort Position <select name="sort">${pages.map((p, i) => `<option${i === sort ? ' selected' : ''}>${i}</option>`).join('')}</select></label>
<footer><button type="submit">Save</button> <button type="button" class="dull" onclick="app.edit(${id}, false)">Cancel</button> <button type="button" class="bad" onclick="app.delete(${id})">Delete</button></footer>`;
					form.onsubmit = e => {
						e.preventDefault();
						q('h1', pg).textContent = form.name.value.trim();
						q('pre', pg).textContent = form.text.value;
						q('footer>time', pg).textContent = new Date().toLocaleString();
						const newSort = parseInt(form.sort.value);
						if (newSort !== sort) {
							const el = pages.splice(sort, 1);
							pages.splice(newSort, 0, el[0]);
							main.innerHTML = '';
							pages.forEach(p => main.appendChild(p));
						}
						app.edit(id, false);
					};
					pg.parentElement.insertBefore(form, pg);
					app.handleTab();
					form.name.focus();
				}
			},
			add() {
				p = document.createElement('section');
				p.id = Date.now();
				const time = new Date().toLocaleString();
				p.innerHTML = /*html*/`<header><h1></h1></header><pre hidden></pre><article></article><footer><time title="Created ${time}">${time}</time> <button class="dull editButton" onclick="app.edit(${p.id})">Edit</edit></footer>`;
				main.appendChild(p);
				nav.appendChild(app.navItem(p));
				app.edit(p.id);
			},
			delete(id) {
				if (confirm('Delete page?')) {
					const p = gebi(id);
					if (p) p.parentElement.removeChild(p);
					const na = gebi(`nav${id}`);
					if (na) na.closest('ul').removeChild(na.parentElement);
					const e = gebi(`edit${id}`);
					if (e) e.parentElement.removeChild(e);
					app.go();
				}
			},
			search(term) {
				const resultsEl = q('#searchResults');
				clearTimeout(resultsEl.debounce);
				resultsEl.debounce = setTimeout(() => {
					resultsEl.innerHTML = '';
					if (!term) return;
					const lcTerm = term.toLowerCase();
					const matches = app.pages().map(p => {
						const i = app.info(p);
						const temp = ce('div');
						temp.innerHTML = md(i.src);
						i.text = temp.textContent;
						return i;
					})
						// Get only pages that contain the search term anywhere in any form
						.filter(({ name, text }) => `${name} ${text}`.match(new RegExp(term, 'i')) !== null)
						.sort((a, b) => {
							const aText = `${a.name} ${a.text}`;
							const bText = `${b.name} ${b.text}`;
							const aIndex = aText.indexOf(term);
							let aIndexCI = aText.toLowerCase().indexOf(lcTerm);
							if (aIndexCI < 0) aIndexCI = Infinity;
							const bIndex = bText.indexOf(term);
							let bIndexCI = bText.toLowerCase().indexOf(lcTerm);
							if (bIndexCI < 0) bIndexCI = Infinity;
							if (aIndex >= 0 && bIndex < 0) return -1;
							if (aIndex < 0 && bIndex >= 0) return -1;
							if (aIndex < 0 && bIndex < 0) {
								if (aIndexCI === bIndexCI) return 0;
								return aIndexCI < bIndexCI ? -1 : 1;
							}
							if (aIndex === bIndex) return 0;
							return aIndex < bIndex ? -1 : 1;
						}).forEach((p) => {
							const mark = t => t.replace(new RegExp(`(${term})`, 'i'), '<mark>$1</mark>');
							const name = mark(p.name);
							const i = p.text.toLowerCase().indexOf(lcTerm);
							const preview = p.text.length < 1 ? '' : p.text.substring(Math.max(0, i - 10), Math.min(100, p.text.length, i + term.length + 10));
							resultsEl.innerHTML += /*html*/`<a href="javascript:app.go(${p.id})">${name}<p class="sm">${mark(preview)}</p></a>`;
						});
				}, 300);
			},
			render(pgId = null) {
				if (!pgId) nav.innerHTML = '';
				const pages = app.pages();
				(!pgId ? pages : [gebi(pgId)]).forEach(p => {
					const { id, name, src } = app.info(p);
					q('pre', p).setAttribute('hidden', '');
					const a = q('article', p);
					const content = src.replace(/\[\[([^\]\|]+)(\|[^\]]+)?\]\]/g, (m, name, text) => {
						return `<a href="javascript:app.go('${name}')">${text ? text.substring(1) : name}</a>`;
					});
					a.innerHTML = md(content);
					a.removeAttribute('hidden');
					if (!pgId) {
						nav.appendChild(app.navItem(p));
					} else {
						gebi(`nav${id}`).textContent = name;
					}
				});
			},
			save() {
				const name = q('#wiki #name');
				const pp = app.pages();
				pp.forEach(p => {
					const txt = q('pre', p).removeAttribute('hidden');
					const a = q('article', p);
					a.setAttribute('hidden', true);
					a.innerHTML = '';
					const edit = gebi(`edit${p.id}`);
					if (edit) edit.parentElement.removeChild(edit);
				});
				app.go();
				document.title = name;
				const html = /*html*/`<!DOCTYPE html><html lang="en">
<head>${document.head.innerHTML}</head>
<body>${document.body.innerHTML}</body></html>`;
				app.render();
				history.back();

				const el = document.createElement('a');
				el.setAttribute('href', 'data:text/html;charset=utf-8,' + encodeURIComponent(html));
				const filename = name.textContent.toLowerCase().replace(/\W/g, '_') + '.html';
				el.setAttribute('download', filename);
				document.body.appendChild(el);
				el.click();
				document.body.removeChild(el);
			},
		};

		w.addEventListener('keydown', e => {
			if (e.ctrlKey && e.key === 's') {
				e.preventDefault();
				app.save();
			}
		});
		w.addEventListener('popstate', e => {
			app.go(h(), true);
		});

		app.render();
		app.go(h());
	})();

	/**
	 * Modified beyond recognition from md.js, a lightweight markdown parser
	 * https://github.com/thysultan/md.js
	 * 
	 * @licence MIT
	 */
	/**
	 * Supports Markdown Features:
	 * - HTML
	 * - headings h1–h6+ (# h1, ## h2, ### h3, etc.)
	 * - paragraphs (\n\n)
	 * - line breaks (	\n)
	 * - blockquotes (> text)
	 * - horizontal rule (---, ***, - - -, * * *)
	 * - code blocks (```)
	 * - inline code (`code`)
	 * - images with alt text & optional title (![alt](image_src "optional title"))
	 * - inline Markdown links with optional title ([link text](link_url "optional title"))
	 * - auto links & email linking (<http://url.domain>, <person@email.example>)
	 * - lists with indentation (- list item, * list item, + list item)
	 * - checkboxes ([ ], [x])
	 * - bold, italic (**bold**, __bold__, *italic*, _italic_, ***bold & italic***, ___bold & italic___, **_bold & italic_**, etc.)
	 * - strikethrough (~~strikethrough~~)
	 * - escaped characters (\*, \_)
	 */
	/**
	 * markdown parser
	 * 
	 * @param	{string} markdown
	 * @return {string}
	 */
	function md(markdown) {
		if (!markdown) {
			return '';
		}

		const charMap = {
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#39;',
			'&': '&amp;',
			'[': '&#91;',
			']': '&#93;',
			'(': '&#40;',
			')': '&#41;',
			'_': '&#95;',
			'*': '&ast;',
			'`': '&#96;',
		};
		// Save non-& charMap values without `&` to more easily check for double-escaped htmlEntity values
		const doubleEscaped = Object.keys(charMap).filter(c => c != '&').map(c => charMap[c].replace(c != '&' ? '&' : '', ''));

		const htmlEntity = str => {
			return str.replace(/[<>&\(\)\[\]"']/g, c => (charMap[c] || c))
				.replace(new RegExp(`&amp;(${doubleEscaped.join('|')})`, 'g'), '&$1');
		}

		var code = [];
		var cIdx = 0; // Code index
		var html = [];
		var hIdx = 0; // HTML index
		var length = markdown.length;

		// to allow matching trailing paragraphs
		if (markdown[length - 1] !== '\n' && markdown[length - 2] !== '\n') {
			markdown += '\n\n';
		}

		// format, removes tabs, leading and trailing spaces
		markdown = (
			markdown
				// escaped characters
				.replace(/\\(.)/g, (m, c) => (charMap[c] || m))
				// collect code blocks and replace with placeholder
				// we do this to avoid code blocks matching the paragraph regexp
				.replace(/```(.*)\n([^\0]+?)```(?!```)/gm, (m, lang, block) => {
					code[cIdx] = { lang, block: htmlEntity(block) };
					return `{code-${cIdx++}}`;
				})
				// inline code
				.replace(/`([^`]+?)`/g, (m, code) => `<code>${htmlEntity(code)}</code>`)
				// auto links
				.replace(/<([^>\s]+(\/\/|@)[^>\s]+)>/g, (m, url, method) => `[${url}](${method === '@' ? 'mailto:' : ''}${url})`)
				// links
				.replace(/(!?)\[([^\]]*?)\]\(([^\s\n]*)(?:| "(.*)")\)/gm, (m, img, text, url, title) => {
					text = htmlEntity(text);
					// try to decode url before re-encoding it in case it has encoded values to prevent encoding the % character
					try { url = decodeURI(url); } catch { } // using try/catch because a malformed URI throws an error
					url = encodeURI(url);
					title = title ? ` title="${htmlEntity(title)}"` : '';
					if (img) return `<img src="${url}" alt="${text}"${title}>`;
					return `<a href="${url}"${title}>${text}</a>`;
				})
				// HTML tags
				.replace(/(<\/?[a-zA-Z]+[^>]*>)/gm, (m, tag) => {
					html[hIdx] = tag;
					return `{html-${hIdx++}}`;
				})
				// blockquotes
				.replace(/^[ \t]*>+ (.*)/gm, '<blockquote>\n$1\n</blockquote>')
				.replace(/(<\/blockquote>\n?<blockquote>)+?/g, '')
				// headings
				.replace(/^(#+) +(.*)/gm, (m, hash, content) => `<h${hash.length}>${content}</h${hash.length}>`)
				// headings h1 (commonmark)
				.replace(/^([^\n\t ])(.*)\n====+/gm, '<h1>$1$2</h1>')
				// headings h2 (commonmark)
				.replace(/^([^\n\t ])(.*)\n----+/gm, '<h2>$1$2</h2>')
				// horizontal rule 
				.replace(/\n( *[-*]){3,}\n/gm, '<hr>')
				// checkboxes
				.replace(/\[( |x)\]/g, (m, checked) => `<input type="checkbox" disabled${checked.toLowerCase() === 'x' ? ' checked' : ''}>`)
				// line breaks
				.replace(/	+\n/gm, '<br>')
				// paragraphs - exclude lists, already-rendered HTML, & whitespace
				.replace(/^([^-\+\*\d<\t \n])([^]*?)(?:\n\n)/gm, (m, leadingCharacter, body) => `<p>${leadingCharacter}${body}</p>\n`)
				// lists
				.replace(/^([\t ]*)(?:(-|\+|\*)|(\d+(?:\)|\.))) (.*)/gm, (m, leading, b, numbered, content) => {
					leading = leading.replace(/	/g, '\t');
					const type = numbered ? 'o' : 'u';
					return `${leading}<${type}l><li>${content}</li></${type}l>`;
				})
		);

		// This handles *almost* all combinations, but some indented lists combining ul & ol don't render right
		var indentListRegExp = /<\/li><\/(u|o)l>\n(\t+)<(u|o)l><li>(.*)<\/li><\/(u|o)l>/;
		while (markdown.match(indentListRegExp)) {
			markdown = markdown.replace(indentListRegExp, function (m, parentEnd, tabs, childStart, content, childEnd) {
				if (tabs.length > 0) {
					tabs = tabs.substring(1);
					if (tabs.length > 0) tabs = '\n' + tabs;
				}
				return `${tabs}<${childStart}l><li>${content}</li></${childEnd}l></li></${parentEnd}l>`;
			});
		}

		markdown = (
			markdown
				// Combine lists
				.replace(/(<\/ul>\n?[ \t]*<ul>)+?/g, '')
				.replace(/(<\/ol>\n?[ \t]*<ol>)+?/g, '')
				// strong
				.replace(/\*\*([^\n*]+?)\*\*/g, '<strong>$1</strong>')
				.replace(/__([^\n_]+?)__/g, '<strong>$1</strong>')
				// emphasis
				.replace(/\*([^\n*]+?)\*/g, '<em>$1</em>')
				.replace(/_([^\n_]+?)_/g, '<em>$1</em>')
				// strike through
				.replace(/(?:~~)([^~]+?)(?:~~)/g, '<del>$1</del>')
		);

		// replace html tag placeholders
		for (let i = 0; i < hIdx; i++) {
			markdown = markdown.replace(`{html-${i}}`, html[i]);
		}

		// replace code block placeholders
		for (let i = 0; i < cIdx; i++) {
			const { lang, block } = code[i];
			markdown = markdown.replace(
				`{code-${i}}`,
				`<pre><code${lang ? ` class="language-${lang}"` : ''}>${htmlEntity(block)}</code></pre>`
			);
		}

		return markdown.trim();
	}
</script>

</body></html>